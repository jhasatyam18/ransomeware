import * as ExcelJS from 'exceljs';
import * as FileSaver from 'file-saver';
import i18n from 'i18next';
import JsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { drPlanStatus } from '../store/actions/DrPlanActions';
import { DETAILED_STEP_COMPONENTS } from '../constants/AppStatus';
import { NUMBER, PLATFORM_TYPES, REPORT_DURATION, STATIC_KEYS, PLAYBOOK_NAMES, NODE_TYPES } from '../constants/InputConstants';
import { ALPHABETS, BLUE, BORDER_STYLE, EXCEL_WORKSHEET_TABLE_HEADER_CELL, EXCEL_WORKSHEET_TITLE, REPORT_TYPES } from '../constants/ReportConstants';
import { ALERTS_COLUMNS, EVENTS_COLUMNS, NODE_COLUMNS, PROTECTED_VMS_COLUMNS, PROTECTION_PLAN_COLUMNS, RECOVERY_JOB_COLUMNS, REPLICATION_JOB_COLUMNS, SITE_COLUMNS, TABLE_REPORTS_CHECKPOINTS } from '../constants/TableConstants';
import { APPLICATION_API_USER } from '../constants/UserConstant';
import { calculateChangedData, convertMinutesToDaysHourFormat, formatTime, getAppDateFormat, getStorageWithUnit } from './AppUtils';
import { getCookie } from './CookieUtils';
import { getValue } from './InputUtils';
import { STORE_KEYS } from '../constants/StoreKeyConstants';
import { clearValues, setActiveTabReport, valueChange } from '../store/actions';
import { validateField } from './validationUtils';
import { addMessage } from '../store/actions/MessageActions';
import { MESSAGE_TYPES } from '../constants/MessageConstants';
import { FIELDS } from '../constants/FieldsConstant';
import { getCriteria, setSelectedSchedule } from '../store/actions/ReportActions';
import { convertScheduleToCron, parseCronToScheduleFields, parseCronToTime, formatTime as schedularFormatTime } from './SystemUpdateScheduleUtils';
import { fetchDrPlans } from '../store/actions/DrPlanActions';
import { REPORTS_PATH } from '../constants/RouterConstants';
import { closeModal } from '../store/actions/ModalActions';

/**
 * Create empty pdf document object
 */
export function createPDFDoc() {
  const doc = new JsPDF('p', 'pt', 'a4');
  return doc;
}

/**
 * Add table to pdf document by id
 * @param {*} id
 */

export function addTableFromData(doc, columns, title, data, user) {
  if (data.length <= 0) {
    return;
  }
  doc.addPage();
  doc.text(title, 10, 30);
  const rows = data.map((item) => columns.map((col) => {
    const keys = (col.field.split('.'));
    const secondaryKeys = (col.secondaryField?.split('.'));
    let value = getValueFromNestedObject(item, keys, secondaryKeys);
    if (value === null || value === '') {
      value = '-';
    } else if (col.type) {
      value = convertValueAccordingToType(value, col.type, item, user);
    }
    if (typeof value === 'string' && value.length > NUMBER.TWO_HUNDRED && col.type !== REPORT_DURATION.RECOVERY_JOB_STEPS) {
      const words = value.split(' ').slice(0, 5);
      value = `${words.join(' ')}...`;
    } else if (typeof value === 'boolean' || value instanceof Boolean) {
      value = value ? 'Yes' : 'No';
    }
    return value;
  }));
  const columnHeaders = columns.map((col) => col.header);
  autoTable(doc, {
    head: [
      [
        {
          content: title,
          colSpan: 1,
          styles: { fontSize: 12, fillColor: 'white', textColor: 'black' },
        },
      ],
    ],
    margin: { left: 5 },
  });
  autoTable(doc, {
    head: [columnHeaders],
    body: rows,
    theme: 'grid',
    tableWidth: 576, // Wrap the table width according to content
    margin: { top: 50, left: 10 }, // Centered horizontally
    styles: { fontSize: 8 },
  });
}

export function addHeading(doc, title) {
  doc.setFontSize(14);
  doc.setTextColor(100);
  doc.text(7, 15, title);
}

export function addTable(doc, data, columns, title, styles = { }) {
  addHeading(doc, title);
  doc.setFontSize(12);
  doc.autoTable(columns, data, {
    columnStyles: styles,
    margin: { top: 60 },
  });
}

export const getBase64FromUrl = async (url) => {
  const data = await fetch(url);
  const blob = await data.blob();
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.readAsDataURL(blob);
    reader.onloadend = () => {
      const base64data = reader.result;
      resolve(base64data);
    };
  });
};
export function addHeaderPage(doc, sites, startDate, endDate) {
  const siteDetails = showSiteDetails(sites);
  const start = getDurationOfReport(startDate);
  const end = getDurationOfReport(endDate);
  const d = new Date();
  doc.setFontSize(48);
  doc.setTextColor('#16a085');
  doc.text(250, 300, 'Datamotive', 'left');
  doc.setFontSize(12);
  doc.setTextColor('#2c3e50');
  doc.text(280, 340, 'Audit report', 'left');
  doc.text(280, 380, siteDetails, 'left');
  doc.text(280, 420, `Generation Date: ${getAppDateFormat(d, true)}`, 'left');
  doc.text(280, 460, `Duration: ${start} - ${end}`, 'left');
  doc.text(280, 500, `Generated by: ${getCookie(APPLICATION_API_USER)}`, 'left');
}

export function systemOverview(doc, data) {
  const { titles, recoveryStats, replicationStats } = data;
  const { sites = 0, protectionPlans = 0, vms = 0, storage = 0 } = titles;
  const { testExecutions = 0, fullRecovery = 0, migrations = 0, rto = 0 } = recoveryStats;
  const { completed, running, failures, dataReduction = 0, changedRate = 0, rpo = 0 } = replicationStats;
  autoTable(doc, {
    head: [
      [
        {
          content: 'System Overview',
          colSpan: 2,
          styles: { halign: 'center' },
        },
      ],
    ],
    body: [
      ['Sites', `${sites}`],
      ['Protection Plans', `${protectionPlans}`],
      ['Protected Machines', `${vms}`],
      ['Protected Storage', getStorageWithUnit(storage)],
      ['Recovery Point Objective (Average across All Protection Plan)', formatTime(rpo)],
      ['Recovery Time Objective (Average across All Recoveries)', formatTime(rto)],
      [{ content: 'Replication Statistics', colSpan: 2, styles: { halign: 'center' } }],
      ['Completed', completed],
      ['Running', running],
      ['Failures', failures],
      ['Data Reduction', calculateDataReduction(dataReduction)],
      ['Change Rate', calculateChangedData(changedRate)],
      [{ content: 'Recovery Statistics', colSpan: 2, styles: { halign: 'center' } }],
      ['Test Recoveries', testExecutions],
      ['Full Recoveries', fullRecovery],
      ['Migrations', migrations],
    ],
    theme: 'grid',
    options: {
      startY: doc.lastAutoTable.finalY + 45,
      rowPageBreak: 'auto',
      margin: { top: 160 },
      bodyStyles: { valign: 'top' },
      styles: { overflow: 'linebreak', cellWidth: 'wrap' },
      columnStyles: { text: { cellWidth: 'auto' } },
    },
  });
}

export async function exportDoc(doc, name) {
  const img = await getBase64FromUrl(REPORT_TYPES.HEADER_IMG_URL);
  const pageCount = doc.internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i += 1) {
    doc.setPage(i);
    doc.addImage(img, 'PNG', 8, 3, doc.internal.pageSize.width - 15, 30);
  }
  doc.save(name);
}

// function getDateFormat(date) {
//   const mNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
//   const m = mNames[date.getMonth()];
//   const d = date.getDate();
//   const y = date.getFullYear();
//   return `${m} ${d}, ${y}`;
// }

function calculateDataReduction(val) {
  if (val === 0) {
    return;
  }
  return `${parseInt(val, 10)}%`;
}

export function addFooters(doc, sites) {
  const pageCount = doc.internal.getNumberOfPages();
  const siteDetails = showSiteDetails(sites);
  const d = new Date(); // Create a Date object
  const year = d.getFullYear();
  doc.setFontSize(6);
  for (let i = 1; i <= pageCount; i += 1) {
    doc.setPage(i);
    doc.text(`Page No - ${String(i)}`, 20, doc.internal.pageSize.height - 10);
    doc.text(siteDetails, 150, doc.internal.pageSize.height - 10);
    doc.text(i18n.t('report.pdf.title', { year }), 330, doc.internal.pageSize.height - 10);
  }
}

const columnsMapping = {
  protectedVMS: PROTECTED_VMS_COLUMNS,
  replication: REPLICATION_JOB_COLUMNS,
  sites: SITE_COLUMNS,
  plans: PROTECTION_PLAN_COLUMNS,
  nodes: NODE_COLUMNS,
  alerts: ALERTS_COLUMNS,
  events: EVENTS_COLUMNS,
  recovery: RECOVERY_JOB_COLUMNS,
  point_in_time_checkpoints: TABLE_REPORTS_CHECKPOINTS,
};

export async function exportTableToExcel(dashboard, data, siteDetails, user) {
  const nameOfWorksheet = ['nodes', 'sites', 'plans', 'protectedVMS', 'replication', 'recovery', 'events', 'alerts', 'point_in_time_checkpoints'];
  const workbook = new ExcelJS.Workbook();
  workbook.views = [{ x: 0, y: 0, width: 5000, firstSheet: 0, activeTab: 0, visibility: 'visible' }];
  const base64ImgUrl = await getBase64FromUrl(REPORT_TYPES.HEADER_IMG_URL);
  worksheetSummary(workbook, dashboard, base64ImgUrl);
  for (let a = 0; a < nameOfWorksheet.length; a += 1) {
    const worksheetName = nameOfWorksheet[a];
    if (data[worksheetName] && data[worksheetName].length > 0) {
      const worksheet = workbook.addWorksheet(i18n.t(nameOfWorksheet[a]), { pageSetup: { paperSize: 5, orientation: 'landscape' } });
      worksheet.columns = columnsMapping[worksheetName].map((col) => ({ header: col.header, key: col.field }));
      addDataToWorksheet(worksheet, columnsMapping[worksheetName], data[worksheetName], workbook, base64ImgUrl, worksheetName, user);
    }
  }
  workbook.xlsx.writeBuffer().then((d) => {
    const blob = new Blob([d], { type: REPORT_TYPES.EXCEL_BLOBTYPE });
    const someDate = new Date();
    const dateFormated = getAppDateFormat(someDate, false);

    FileSaver.saveAs(blob, `DM-Report-${siteDetails}-${dateFormated}.xlsx`);
  });
}

function worksheetSummary(wb, dashboard, base64ImgUrl) {
  const workbook = wb;
  const worksheet = workbook.addWorksheet('Summary', { pageSetup: { paperSize: 5, orientation: 'landscape' } });
  addingHeaderItemToWorksheet(16, workbook, worksheet, base64ImgUrl, 'System Overview');
  summaryInfo(worksheet, dashboard);
}

function AdjustColumnWidth(ws) {
  const worksheet = ws;
  worksheet.columns.forEach((col) => {
    const column = col;
    const lengths = column.values.map((v) => { if (v) { return v.toString().length + 6; } });
    let maxLength = Math.max(...lengths.filter((v) => typeof v === 'number'));
    if (maxLength > NUMBER.ONE_HUNDRED) {
      maxLength = NUMBER.ONE_HUNDRED;
    }
    column.width = maxLength;
  });
  addingStyleToWorksheet(worksheet);
}

function addingStyleToWorksheet(ws) {
  const worksheet = ws;
  const { bodyBg, linkColor, bodyColor, cardHeaderBg } = getThemeColorForReports();
  worksheet.columns.forEach((col) => {
    // style Each column in worksheet
    const column = col;
    column.border = BORDER_STYLE;
    column.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: bodyBg }, bgColor: { argb: bodyBg } };
    column.font = { color: { argb: bodyColor } };
    column.alignment = { wrapText: true, horizontal: 'center', vertical: 'middle' };
  });
  // apply blue font color and light blue background color in the header of the table
  worksheet.columns.map((pl, ind) => {
    const key = EXCEL_WORKSHEET_TABLE_HEADER_CELL[ind];
    worksheet.getCell(key).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: bodyBg }, bgColor: { argb: bodyBg } };
    worksheet.getCell(key).font = { size: 12 };
    worksheet.getCell(key).font = { color: { argb: BLUE } };
  });
  // apply gray font color and dark blue background color to the title of the Table
  worksheet.columns.map((pl, ind) => {
    const key = EXCEL_WORKSHEET_TITLE[ind];
    worksheet.getCell(key).font = { size: 14 };
    worksheet.getCell(key).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: cardHeaderBg }, bgColor: { argb: cardHeaderBg } };
    worksheet.getCell(key).font = { color: { argb: linkColor } };
  });
}

export function getThemeColorForReports() {
  const root = getComputedStyle(document.documentElement);
  return {
    bodyBg: root.getPropertyValue('--bs-body-bg').trim().substring(1),
    bodyColor: root.getPropertyValue('--bs-body-color').trim().substring(1) === 'fff' ? 'ffffff' : root.getPropertyValue('--bs-body-color').trim().substring(1),
    linkColor: root.getPropertyValue('--tree-fd-color').trim().substring(1),
    cardHeaderBg: root.getPropertyValue('--bs-card-cap-bg').trim().substring(1),
  };
}

/**
 *
 * @param {*} oTable
 * @param {*} wb = workbook
 * @param {*} ws =worksheet
 * @param {*} base64ImgUrl = image url to base64
 * @param {*} title = title of the worksheet
 */

function addingHeaderItemToWorksheet(oTable, wb, ws, base64ImgUrl, title) {
  const workbook = wb;
  const worksheet = ws;
  // for getting the aplabets row in the excelsheet
  let totalCol = '';
  if (typeof oTable === 'object') {
    totalCol = oTable.rows.item(0).cells.length - 1;
  } else {
    totalCol = oTable;
  }
  // setting the image header in the worksheet
  const imageId = workbook.addImage({
    base64: base64ImgUrl,
    extension: 'png',
  });
  worksheet.addImage(imageId, `A1:${ALPHABETS[totalCol]}2`);
  worksheet.mergeCells(`A1:${ALPHABETS[totalCol]}2`);
  worksheet.mergeCells('A3', `${ALPHABETS[totalCol]}4`);
  // for setting title to the worksheet
  worksheet.getCell('A3').value = title;
  worksheet.getCell('A3').style = { font: { name: 'Century Gothic' }, alignment: { vertical: 'middle', horizontal: 'center' } };
}

function summaryInfo(ws, dashboard) {
  const worksheet = ws;
  const excelData = getExcelData(dashboard);
  const { bodyBg, bodyColor } = getThemeColorForReports();
  excelData.forEach((e) => {
    mergeCells(worksheet, e);
  });
  // for setting summary page title
  ['A3'].map((key) => {
    worksheet.getCell(key).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: bodyBg }, bgColor: { argb: bodyBg } };
    worksheet.getCell(key).font = { color: { argb: bodyColor }, size: 12 };
  });
}

/**
 *It will set boxes for summary and set its style
 * @param {*} ws= worksheet
 * @param {*} obj has cell information
 */
export function mergeCells(ws, obj) {
  const worksheet = ws;
  const { mergeCell, value, backgroundColor, fontColor, fontSize } = obj;
  const firstCell = mergeCell.split(':');
  worksheet.mergeCells(mergeCell);
  worksheet.getCell(firstCell[0]).value = value;
  worksheet.getCell(firstCell[0]).style = { font: { name: 'Century Gothic', color: { argb: fontColor }, size: fontSize || 8 }, alignment: { vertical: 'middle', horizontal: 'center' } };
  worksheet.getCell(firstCell[0]).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: backgroundColor }, bgColor: { argb: backgroundColor } };
}

function getExcelData(dashboard) {
  const { titles, replicationStats, recoveryStats } = dashboard;
  const { sites, vms, storage, protectionPlans } = titles;
  const { running, completed, failures, changedRate, dataReduction, rpo } = replicationStats;
  const { fullRecovery, migrations, testExecutions, rto } = recoveryStats;
  const { bodyBg, bodyColor, cardHeaderBg, linkColor } = getThemeColorForReports();
  const excel = [
    { mergeCell: 'B6:D7', fontColor: linkColor, backgroundColor: bodyBg, value: 'Sites', fontSize: 8 },
    { mergeCell: 'B8:D9', fontColor: bodyColor, backgroundColor: bodyBg, value: sites },
    { mergeCell: 'F6:H7', fontColor: linkColor, backgroundColor: bodyBg, value: 'Protection Plans', fontSize: 8 },
    { mergeCell: 'F8:H9', fontColor: bodyColor, backgroundColor: bodyBg, value: protectionPlans },
    { mergeCell: 'J6:L7', fontColor: linkColor, backgroundColor: bodyBg, value: 'Protected Machine', fontSize: 8 },
    { mergeCell: 'J8:L9', fontColor: bodyColor, backgroundColor: bodyBg, value: vms },
    { mergeCell: 'N6:P7', fontColor: linkColor, backgroundColor: bodyBg, value: 'Storage', fontSize: 8 },
    { mergeCell: 'N8:P9', fontColor: bodyColor, backgroundColor: bodyBg, value: getStorageWithUnit(storage) },
    { mergeCell: 'B11:H12', fontColor: bodyColor, backgroundColor: cardHeaderBg, value: 'Replication Statistics', fontSize: 10 },
    { mergeCell: 'J11:P12', fontColor: bodyColor, backgroundColor: cardHeaderBg, value: 'Recovery Statistics', fontSize: 10 },
    { mergeCell: 'B13:D14', fontColor: linkColor, backgroundColor: bodyBg, value: 'Completed', fontSize: 8 },
    { mergeCell: 'B15:D15', fontColor: bodyColor, backgroundColor: bodyBg, value: completed },
    { mergeCell: 'E13:F14', fontColor: linkColor, backgroundColor: bodyBg, value: 'Running', fontSize: 8 },
    { mergeCell: 'E15:F15', fontColor: bodyColor, backgroundColor: bodyBg, value: running },
    { mergeCell: 'G13:H14', fontColor: linkColor, backgroundColor: bodyBg, value: 'Failure', fontSize: 8 },
    { mergeCell: 'G15:H15', fontColor: bodyColor, backgroundColor: bodyBg, value: failures },
    { mergeCell: 'J13:L14', fontColor: linkColor, backgroundColor: bodyBg, value: 'Test Recovery', fontSize: 8 },
    { mergeCell: 'J15:L15', fontColor: bodyColor, backgroundColor: bodyBg, value: testExecutions },
    { mergeCell: 'M13:N14', fontColor: linkColor, backgroundColor: bodyBg, value: 'Recovery', fontSize: 8 },
    { mergeCell: 'M15:N15', fontColor: bodyColor, backgroundColor: bodyBg, value: fullRecovery },
    { mergeCell: 'O13:P14', fontColor: linkColor, backgroundColor: bodyBg, value: 'Migration', fontSize: 8 },
    { mergeCell: 'O15:P15', fontColor: bodyColor, backgroundColor: bodyBg, value: migrations },
    { mergeCell: 'B17:D18', fontColor: linkColor, backgroundColor: bodyBg, value: 'Change Rate', fontSize: 8 },
    { mergeCell: 'B19:D19', fontColor: bodyColor, backgroundColor: bodyBg, value: calculateChangedData(changedRate) },
    { mergeCell: 'F17:H18', fontColor: linkColor, backgroundColor: bodyBg, value: 'Data Reduction', fontSize: 8 },
    { mergeCell: 'F19:H19', fontColor: bodyColor, backgroundColor: bodyBg, value: `${parseInt(dataReduction, 10)}%` },
    { mergeCell: 'J17:L18', fontColor: linkColor, backgroundColor: bodyBg, value: 'RPO', fontSize: 8 },
    { mergeCell: 'J19:L19', fontColor: bodyColor, backgroundColor: bodyBg, value: formatTime(rpo) },
    { mergeCell: 'N17:P18', fontColor: linkColor, backgroundColor: bodyBg, value: 'RTO', fontSize: 8 },
    { mergeCell: 'N19:P19', fontColor: bodyColor, backgroundColor: bodyBg, value: formatTime(rto) },
  ];
  return excel;
}

export async function exportIssues(data) {
  let issues = data;
  if (typeof issues === 'undefined') {
    issues = [];
  }
  // Create a new workbook
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet('Identified_Issues');
  worksheet.addRow(['Name', 'Error Messages']);
  issues.forEach((entry) => {
    entry.errorMessages.forEach((errorMessage, index) => {
      if (index === 0) {
        worksheet.addRow([entry.name, errorMessage]);
      } else {
        // For subsequent messages, leave the name column empty
        worksheet.addRow(['', errorMessage]);
      }
    });
  });
  // Define columns widths for better readability
  worksheet.columns = [
    { header: 'Name', key: 'name', width: 30 },
    { header: 'Error Messages', key: 'errorMessage', width: 50 },
  ];

  // Write the Excel file to disk
  workbook.xlsx.writeBuffer().then((d) => {
    const blob = new Blob([d], { type: REPORT_TYPES.EXCEL_BLOBTYPE });
    const someDate = new Date();
    const dateFormated = getAppDateFormat(someDate, false);

    FileSaver.saveAs(blob, `${PLAYBOOK_NAMES.ISSUES}-${dateFormated}.xlsx`);
  });
}

function formatTimeValue(value) {
  if (value === 0) {
    return '-';
  }
  // Convert milliseconds to readable time
  const milliseconds = value * 1000;
  const date = new Date(milliseconds);
  return date.toLocaleString();
}

function formatSize(size) {
  const KB = 1024;
  const MB = KB * 1024;
  const GB = MB * 1024;

  if (size < MB) {
    return `${(size / KB).toFixed(2)} KB`;
  }
  if (size >= MB && size < GB) {
    return `${(size / MB).toFixed(2)} MB`;
  }
  return `${(size / GB).toFixed(2)} GB`;
}

export function getRecoveryStatus(data) {
  let { recoveryStatus, reverseStatus } = data;

  if (recoveryStatus) {
    recoveryStatus = recoveryStatus.charAt(0).toUpperCase() + recoveryStatus.slice(1);
    return recoveryStatus;
  }
  if (reverseStatus) {
    reverseStatus = reverseStatus.charAt(0).toUpperCase() + reverseStatus.slice(1);
    return reverseStatus;
  }
  return '-';
}

export function getAlertTitleWithOccurrence(data) {
  const { title, occurrence } = data;
  if (!title) {
    return '-';
  }
  if (occurrence && occurrence > 1) {
    return `${title} (${occurrence})`;
  }
  return title;
}

export function getVMNameWithSyncStatus(data) {
  const { vmName, syncStatus } = data;
  if (!syncStatus && vmName) {
    return vmName;
  }
  if (vmName && syncStatus) {
    return `${vmName}\n \n ${syncStatus}`;
  }
  return '-';
}

export function getRecoveryTimingAndDuration(data) {
  const { startTime = 0, endTime = 0 } = data;
  const start = formatTimeValue(startTime);
  const end = formatTimeValue(endTime);
  const duration = timeDuration(data);
  return `${start}\n${end}\n${duration}`;
}

export function getReplicationStatus(data) {
  const newStatus = drPlanStatus(data);
  if (newStatus === STATIC_KEYS.STARTED) {
    return STATIC_KEYS.RUNNING;
  }
  return newStatus;
}
export function getRecoveryStatusStep(data = {}) {
  if (!data || typeof data !== 'object') {
    return '-';
  }
  const { status, step } = data;
  let stepsText = '';
  if (step !== '') {
    const parsedSteps = JSON.parse(step);
    stepsText = parsedSteps.map((s) => {
      const stepName = s.name || '';
      let stepStatus = s.status === 'failed' ? STATIC_KEYS.REC_STEP_FAIL : 'Running';
      if (s.status === STATIC_KEYS.COMPLETED) {
        let subSteps = [];
        if (s.data && s.data !== '') {
          subSteps = JSON.parse(s.data); // Parse the substeps
        }
        let hasFailedSubstep = false;
        if (s.name === DETAILED_STEP_COMPONENTS.PENDING_STATUS_STEPS && subSteps.length > 0) {
          subSteps.forEach((pd) => {
            const { result } = pd;
            if (result === STATIC_KEYS.REC_STEP_FAIL) {
              hasFailedSubstep = true;
            }
          });
        } else if (subSteps.length > 0) {
          subSteps.forEach((pd) => {
            const key = Object.keys(pd);
            const detailedStepStatus = pd[key[0]].result;
            if (detailedStepStatus === STATIC_KEYS.REC_STEP_FAIL) {
              hasFailedSubstep = true;
            }
          });
        }
        stepStatus = hasFailedSubstep ? 'Partially-Completed' : STATIC_KEYS.REC_STEP_PASS;
      }
      const stepTime = s.time * 1000;
      let time = new Date(stepTime);
      time = `${time.toLocaleTimeString()}` || '-';
      return `* ${stepName} - ${stepStatus}\n  Time: ${time}`;
    }).join('\n');
  }
  return `${status.charAt(0).toUpperCase() + status.slice(1)}${step !== '' ? `\nSteps:\n${stepsText}` : ''}`;
}

const getReportVMSIteration = (data, value) => {
  if (!data.totalIteration) {
    return '-';
  }
  return value;
};

const getReportVMSSizes = (data, value) => {
  if (!data.totalIteration) {
    return '-';
  }
  return formatSize(value);
};

export function getCheckpointExpiration(data) {
  if (!data || data.isPreserved) {
    return '-';
  }
  return formatTimeValue(data.expirationTime);
}

export function getNodePlatformType(data, user) {
  if (typeof data === 'undefined') {
    return '-';
  }
  const { platformType } = data;
  let dataToShow = platformType;
  if (dataToShow === '' && user && user.platformType) {
    dataToShow = user.platformType;
  }

  return dataToShow;
}

function getRecoveryType(value) {
  if (!value) {
    return '-';
  }
  return value.charAt(0).toUpperCase() + value.slice(1);
}

function convertValueAccordingToType(value, type, data = {}, user) {
  switch (type) {
    case REPORT_DURATION.SIZE:
      return formatSize(value);
    case REPORT_DURATION.DATE:
      return formatTimeValue(value);
    case REPORT_DURATION.TIME:
      return convertMinutesToDaysHourFormat(value);
    case REPORT_DURATION.DURATION:
      return timeDuration(data);
    case REPORT_DURATION.LOCATION:
      return SetLocationAccordingToPlatform(data);
    case STATIC_KEYS.REPORT_STATUS_TYPE:
      return SetAlertStatus(data);
    case STATIC_KEYS.PORTS_RENDERER:
      return getPortsOfNode(data);
    case STATIC_KEYS.RECOVER_STATUS:
      return getRecoveryStatus(data);
    case STATIC_KEYS.ALERT_TITLE:
      return getAlertTitleWithOccurrence(data);
    case STATIC_KEYS.REPLICATION_JOB_VM_NAME:
      return getVMNameWithSyncStatus(data);
    case STATIC_KEYS.RECOVERY_DATE_DURATION:
      return getRecoveryTimingAndDuration(data);
    case REPORT_DURATION.REPLICATION_STATUS:
      return getReplicationStatus(data);
    case REPORT_DURATION.AVERAGE_RPO_RTO:
      return formatTime(value);
    case REPORT_DURATION.CHECKPOINT_EXPIRATION_TIME:
      return getCheckpointExpiration(data);
    case REPORT_DURATION.NODE_TYPE_RENDERER:
      return getNodePlatformType(data, user);
    case REPORT_DURATION.RECOVERY_JOB_STEPS:
      return getRecoveryStatusStep(data);
    case REPORT_DURATION.REPORT_VMS_ITERATION:
      return getReportVMSIteration(data, value);
    case REPORT_DURATION.REPORT_VMS_SIZE:
      return getReportVMSSizes(data, value);
    case REPORT_DURATION.REPORT_RECOVERY_TYPE:
      return getRecoveryType(value);
    default:
      return value;
  }
}

function addDataToWorksheet(worksheet, columns, data, workbook, base64ImgUrl, header, user) {
  addingHeaderItemToWorksheet(columns.length - 1, workbook, worksheet, base64ImgUrl, header.split('_').join(' ').toUpperCase());
  const headerRow = columns.map((col) => col.header);
  const heading = worksheet.addRow(headerRow);
  heading.eachCell((cell) => {
    const headerCell = cell;
    headerCell.font = {
      color: { rgb: '000' },
      bold: true,
    };
    headerCell.alignment = {
      vertical: 'middle',
      horizontal: 'center',
    };
  });
  data.forEach((item) => {
    const row = {};
    columns.forEach((col) => {
      const keys = (col.field.split('.'));
      const secondaryKeys = (col.secondaryField?.split('.'));
      let value = getValueFromNestedObject(item, keys, secondaryKeys);
      if (value === null || value === '') {
        value = '-';
      } else if (col.type) {
        value = convertValueAccordingToType(value, col.type, item, user);
      }
      if (typeof value === 'string') {
        const words = value.split(' ');
        if (words.length > NUMBER.TWO_HUNDRED) {
          value = `${words.slice(0, 5).join(' ')}...`;
        }
      } else if (typeof value === 'boolean' || value instanceof Boolean) {
        value = value ? 'Yes' : 'No';
      }
      row[col.field] = value;
    });
    const dataRow = worksheet.addRow(row);
    dataRow.eachCell((cell) => {
      const dataCell = cell;
      dataCell.alignment = {
        vertical: 'middle',
        horizontal: 'center',
      };
    });
  });
  AdjustColumnWidth(worksheet);
}

function getValueFromNestedObject(item, keys, secondaryKeys) {
  let val = keys.reduce((acc, key) => acc && acc[key], item);
  if ((val === '' || val === null) && secondaryKeys) {
    val = secondaryKeys.reduce((acc, k) => acc && acc[k], item);
  }
  return val;
}

export function getReportDurationOptions() {
  return [
    { label: 'Custom', value: REPORT_DURATION.CUSTOM },
    { label: 'Current Week', value: REPORT_DURATION.WEEK },
    { label: 'Current Month', value: REPORT_DURATION.MONTH },
    { label: 'Current Year', value: REPORT_DURATION.YEAR },
  ];
}

export const showReportDurationDate = (user) => {
  const { values } = user;
  const durationType = getValue(STATIC_KEYS.REPORT_DURATION_TYPE, values);
  if (durationType === REPORT_DURATION.CUSTOM) {
    return true;
  }
  return false;
};

export function getStartDate(type) {
  const today = new Date();
  switch (type) {
    case REPORT_DURATION.WEEK:
      const day = today.getDay();
      const diff = today.getDate() - day + (day === 0 ? -6 : 1);
      today.setDate(diff);
      break;
    case REPORT_DURATION.MONTH:
      today.setDate(1);
      break;
    case REPORT_DURATION.YEAR:
      today.setMonth(0, 1);
      break;
    default:
      break;
  }
  today.setHours(0, 0, 0, 0);
  return today.getTime();
}

export function setMinDateForReport({ user }) {
  const { values } = user;
  const startDate = getValue(STATIC_KEYS.REPORT_DURATION_START_DATE, values);
  return startDate === '' ? new Date() : startDate;
}

export function timeDuration(data) {
  const { startTime, endTime } = data;
  if (endTime === 0) {
    return formatTimeValue(startTime);
  }
  if (startTime && endTime) {
    const sDate = new Date(startTime * 1000);
    const eDate = new Date(endTime * 1000);
    const duration = formatTime(Math.ceil(eDate - sDate) / 1000);
    return duration;
  }
  return '-';
}

export function SetLocationAccordingToPlatform(data) {
  const { availZone, hostname, region, platformType } = data.platformDetails;
  if (platformType === PLATFORM_TYPES.VMware) {
    return hostname;
  }
  if (platformType === PLATFORM_TYPES.Azure) {
    return region;
  }
  return availZone;
}

export function SetAlertStatus(data = {}) {
  const isAcknowledged = data.isAcknowledge;
  if (isAcknowledged) {
    return 'Acknowledged';
  }
  return 'Not Acknowledged';
}

function getPortsOfNode(data) {
  const mgmtPort = data.managementPort;
  const replCtrlPort = data.replicationCtrlPort;
  const replDataPort = data.replicationDataPort;
  let replPort = 0;
  if (mgmtPort === 0 && replCtrlPort === 0 && replDataPort === 0 && data.nodeType === NODE_TYPES.PrepNode) {
    return '5985-5986';
  }
  if (mgmtPort === 0 && replCtrlPort === 0 && replDataPort === 0) {
    return '-';
  }

  if (replCtrlPort !== 0 && replDataPort !== 0) {
    replPort = `${replCtrlPort}, ${replDataPort}`;
  } else if (replCtrlPort !== 0) {
    replPort = replCtrlPort;
  } else if (replDataPort !== 0) {
    replPort = replDataPort;
  }
  if (mgmtPort === 0) {
    return replPort;
  }
  return `${mgmtPort}, ${replPort}`;
}

export function showSiteDetails(sites = []) {
  const localSite = sites.find((site) => site.node.isLocalNode);
  if (!localSite) {
    return '';
  }
  const { name, platformDetails } = localSite;
  const { availZone, platformType, hostname, region } = platformDetails;
  let location;
  if (platformType === PLATFORM_TYPES.VMware) {
    location = hostname;
  } else if (platformType === PLATFORM_TYPES.Azure) {
    location = region;
  } else {
    location = availZone;
  }
  return `${name} (${platformType} ${location})`;
}

export function showSelectPlanError(user) {
  const { values } = user;
  const protectionPlan = getValue(STATIC_KEYS.REPORT_PROTECTION_PLAN, values);
  if (typeof protectionPlan === 'undefined' || protectionPlan === '') {
    const machinesSelected = getValue('report.protectionPlan.includeProtectedVMS', values);
    const pointInTimeSelected = getValue('report.protectionPlan.includeCheckpoints', values);
    const replJobSelected = getValue('report.protectionPlan.includeReplicationJobs', values);
    const recJobSelected = getValue('report.protectionPlan.includeRecoveryJobs', values);
    if (machinesSelected || pointInTimeSelected || replJobSelected || recJobSelected) {
      return true;
    }
  }
  return false;
}

export function getDurationOfReport(date) {
  const milliseconds = parseInt(date, 10) * 1000; // Convert to milliseconds
  const d = new Date(milliseconds); // Create a Date object
  const day = String(d.getDate()).padStart(2, '0');
  const month = d.toLocaleString('en-US', { month: 'short' });
  const year = d.getFullYear();
  const hours = d.getHours() % 12 || 12; // Convert to 12-hour format
  const minutes = String(d.getMinutes()).padStart(2, '0');
  const ampm = d.getHours() >= 12 ? 'PM' : 'AM';

  return `${day}-${month}-${year} ${hours}:${minutes} ${ampm}`;
}

export const onReportOccurrenceChange = () => (dispatch) => {
  dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE, 1));
};

export const showReportDayOfMonthField = (user) => {
  const occurrenceOption = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE_OPTION, user.values) || '';
  if (occurrenceOption === 'week' || occurrenceOption === 'day') {
    return false;
  }
  return true;
};

const FREQUENCY_MAP = {
  hour: 'hourly',
  day: 'daily',
  week: 'weekly',
  month: 'monthly',
};

export const getReportSchedulePayload = (user, data = {}) => {
  const { values } = user;
  const criteria = getCriteria(user) || {};
  const plans = getValue(STATIC_KEYS.UI_PROTECTION_PLANS, values) || [];
  let type;
  const occurrenceOption = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE_OPTION, values) || '';
  if (occurrenceOption === STATIC_KEYS.DAY) type = 'Days';
  else if (occurrenceOption === STATIC_KEYS.WEEK) type = 'Week';
  else if (occurrenceOption === STATIC_KEYS.MONTH) type = 'Month';
  else type = 'Hourly';
  const name = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_NAME, values) || '';
  const timeZone = getValue(STORE_KEYS.UI_REPORT_SCHEDULE_TIME_ZONE, values) || '';
  const occurrence = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE, values) || 1;
  const dayOfWeek = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_DAY_OF_WEEK, values) || [];
  const dayOfMonth = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_DAY_OF_MONTH, values) || [];
  const time = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_GENERATE_ON_TIME, values) || '';
  const emailIDs = getValue('schedule.report.email', values) || '';
  const maintain = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_MAINTAIN, values) || '';
  const fileType = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_FORMAT_TYPE, values) || '';
  let protectionPlan = getValue(STATIC_KEYS.REPORT_PROTECTION_PLAN, values) || '';
  if (protectionPlan === 'All') {
    protectionPlan = plans?.map((p) => p.id).join(',');
  }
  const replicationJobFilters = getValue('report.protectionPlan.replJobOption', values) || '';
  const recoveryJobFilters = getValue('report.protectionPlan.recoveryJobOption', values) || '';
  let cronString = convertScheduleToCron({ type, repeat: occurrence, dayOfWeek, dayOfMonth, time: schedularFormatTime(time) });
  cronString = `0 ${cronString}`;

  const payload = {
    config: {
      alerts: !!criteria.includeAlerts,
      events: !!criteria.includeEvents,
      nodes: !!criteria.includeNodes,
      protectionPlanConfig: {
        pointInTimeCheckpoints: !!criteria.includeCheckpoints,
        protectedMachines: !!criteria.includeProtectedVMS,
        protectionPlans: protectionPlan,
        recoveryJobFilters,
        recoveryJobs: !!criteria.includeRecoveryJobs,
        replicationJobFilters,
        replicationJobs: !!criteria.includeReplicationJobs,
      },
    },
    cronString,
    disabled: Object.keys(data).length > 0 ? data.disabled : false,
    emailIDs,
    fileType,
    frequency: FREQUENCY_MAP[occurrenceOption],
    name,
    reportsToRetain: maintain,
    timezone: timeZone?.value,
  };
  return payload;
};

export const getMinMaxForReportSchedulerOccurence = (user) => {
  const { values } = user;
  const occurenceOptionValue = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE_OPTION, values);
  switch (occurenceOptionValue) {
    case STATIC_KEYS.WEEK:
      return { min: 1, max: 4 };
    case STATIC_KEYS.MONTH:
      return { min: 1, max: 12 };
    case STATIC_KEYS.DAY:
      return { min: 1, max: 30 };
    case STATIC_KEYS.HOURLY:
      return { min: 1, max: 24 };
    default:
      break;
  }
};

export const getMinMaxForReportSchedulerMaintanance = () => ({ min: 1, max: 10 });

const showTime = (timeStr) => {
  if (!timeStr) return '';
  const date = new Date(timeStr);
  return date.toLocaleTimeString('en-US', {
    hour: 'numeric',
    minute: '2-digit',
    hour12: true,
  });
};

export const getReportScheduleText = (user) => {
  const { values } = user;
  const occurrenceOptionValue = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE_OPTION, values);
  const time = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_GENERATE_ON_TIME, values);
  const occurrence = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE, values) || 1;
  const days = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_DAY_OF_WEEK, values) || [];
  const monthDay = getValue(STORE_KEYS.UI_REPORT_SCHEDULER_DAY_OF_MONTH, values) || [];
  switch (occurrenceOptionValue) {
    case STATIC_KEYS.WEEK: {
      const readableTime = showTime(time);
      const readableDays = days.length > 0 ? days.join(' and ') : '';
      return `Generate report at ${readableTime} on every ${readableDays}`;
    }
    case STATIC_KEYS.DAY: {
      const readableTime = showTime(time);
      if (occurrence === 1) {
        return `Generate report every day at ${readableTime}`;
      }
      return `Generate report on every ${occurrence} days at ${readableTime}`;
    }
    case STATIC_KEYS.HOURLY: {
      if (occurrence === 1) {
        return 'Generate report every hour';
      }
      return `Generate report after every ${occurrence} hours`;
    }
    case STATIC_KEYS.MONTH: {
      const readableTime = showTime(time);
      if (occurrence === 1) {
        return `Generate report at ${readableTime} on day ${monthDay} of every month`;
      }
      return `Generate report at ${readableTime} on day ${monthDay} of every ${occurrence} months`;
    }
    default:
      return '-';
  }
};

export const getReportFieldConfig = () => {
  const fieldConfig = {
    [STORE_KEYS.UI_REPORT_SCHEDULER_NAME]: FIELDS['ui.report.schedule.name'],
    [STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE_OPTION]: FIELDS['ui.report.schedule.day'],
    [STORE_KEYS.UI_REPORT_SCHEDULE_TIME_ZONE]: FIELDS['ui.report.schedule.time.zone'],
    [STORE_KEYS.UI_REPORT_SCHEDULER_EMAIL]: FIELDS['schedule.report.email'],
    [STORE_KEYS.UI_REPORT_SCHEDULER_FORMAT_TYPE]: FIELDS['report.format.type'],
  };
  return fieldConfig;
};

export function validateCreateScheduleStep(user, dispatch, stepIndex) {
  const { values } = user;
  const fieldConfigMap = getReportFieldConfig(user);
  let fields = [];
  switch (stepIndex) {
    case 0: // Schedule
      fields = [
        STORE_KEYS.UI_REPORT_SCHEDULER_NAME,
        STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE_OPTION,
        STORE_KEYS.UI_REPORT_SCHEDULE_TIME_ZONE,
      ];
      break;
    case 1: // Configure
      if (showSelectPlanError(user)) {
        dispatch(addMessage('Please select protection plan', MESSAGE_TYPES.ERROR));
        return false;
      }
      fields = [STORE_KEYS.UI_REPORT_SCHEDULER_FORMAT_TYPE];
      break;
    case 2: // Email
      fields = [
        STORE_KEYS.UI_REPORT_SCHEDULER_EMAIL,
      ];
      break;
    default:
      return true;
  }
  let isValid = true;
  fields.forEach((fieldKey) => {
    const field = fieldConfigMap[fieldKey];
    if (!field) return;
    const value = getValue(fieldKey, values);
    if (!validateField(field, fieldKey, value, dispatch, user)) {
      isValid = false;
    }
  });
  return isValid;
}

export const getTimeZoneOptions = (user) => {
  const timeZoneOptions = getValue(STORE_KEYS.UI_SCHEDULE_TIME_ZONE_OPTIONS, user.values) || [];
  return timeZoneOptions;
};

export const defaultReportScheduleTimeZone = ({ dispatch }) => {
  const { timeZone } = Intl.DateTimeFormat().resolvedOptions();
  const defaultZone = { label: timeZone, value: timeZone };
  dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULE_TIME_ZONE, defaultZone));
  return defaultZone;
};

export function setReconfigureReportScheduleData(data = []) {
  return (dispatch, getState) => {
    const { drPlans } = getState();
    const { plans = [] } = drPlans;
    const { config = {} } = data;
    const { protectionPlanConfig = {} } = config;
    const cronString = data.cronString || '';
    const parsed = parseCronToScheduleFields(cronString);
    if (parsed.type === STATIC_KEYS.WEEK) {
      dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULER_DAY_OF_WEEK, parsed.dayOfWeek));
    } else if (parsed.type === STATIC_KEYS.MONTH) {
      dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULER_DAY_OF_MONTH, +parsed.dayOfMonth));
    }
    const generateTime = parseCronToTime(cronString);
    const occurrenceKey = Object.keys(FREQUENCY_MAP).find((key) => FREQUENCY_MAP[key] === data.frequency);
    dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULE_WORKFLOW, STATIC_KEYS.EDIT));
    dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULER_NAME, data.name));
    dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULER_GENERATE_ON_TIME, generateTime));
    const occurrenceValue = occurrenceKey === STATIC_KEYS.HOURLY ? getHourlyStepFromCron(cronString) : 1;
    dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE, occurrenceValue));
    dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULER_OCCURRENCE_OPTION, occurrenceKey));
    dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULER_FORMAT_TYPE, data.fileType));
    dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULE_TIME_ZONE, { label: data.timezone, value: data.timezone }));
    dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULER_EMAIL, data.emailIDs));
    dispatch(valueChange(STORE_KEYS.UI_REPORT_SCHEDULER_MAINTAIN, data.reportsToRetain));
    dispatch(valueChange('report.system.includeSystemOverView', true));
    dispatch(valueChange('report.system.includeNodes', !!config.nodes));
    dispatch(valueChange('report.system.includeEvents', !!config.events));
    dispatch(valueChange('report.system.includeAlerts', !!config.alerts));
    dispatch(valueChange('report.protectionPlan.includeReplicationJobs', !!protectionPlanConfig.replicationJobs));
    dispatch(valueChange('report.protectionPlan.includeRecoveryJobs', !!protectionPlanConfig.recoveryJobs));
    dispatch(valueChange('report.protectionPlan.includeCheckpoints', !!protectionPlanConfig.pointInTimeCheckpoints));
    dispatch(valueChange('report.protectionPlan.includeProtectedVMS', !!protectionPlanConfig.protectedMachines));
    if (data.config?.protectionPlanConfig?.recoveryJobFilters) {
      dispatch(valueChange('report.protectionPlan.recoveryJobOption', protectionPlanConfig.recoveryJobFilters));
      const recFilters = data.config.protectionPlanConfig.recoveryJobFilters.split(',').map((f) => f.trim()).filter(Boolean)
        .map((f) => ({
          value: f,
          label: f.replace(/\b\w/g, (c) => c.toUpperCase()), // capitalize each word
        }));
      dispatch(valueChange('report.protectionPlan.recoveryJobOption-reportfilter-selected-option', recFilters));
    }
    if (data.config?.protectionPlanConfig?.replicationJobFilters) {
      dispatch(valueChange('report.protectionPlan.replJobOption', protectionPlanConfig.replicationJobFilters));
      const replFilters = data.config.protectionPlanConfig.replicationJobFilters.split(',').map((f) => f.trim()).filter(Boolean)
        .map((f) => ({
          value: f,
          label: f.replace(/\b\w/g, (c) => c.toUpperCase()),
        }));
      dispatch(valueChange('report.protectionPlan.replJobOption-reportfilter-selected-option', replFilters));
    }
    if (protectionPlanConfig.protectionPlans) {
      if (protectionPlanConfig?.protectionPlans?.split(',').length === plans.length) {
        dispatch(valueChange(STATIC_KEYS.REPORT_PROTECTION_PLAN, 'All'));
      } else {
        dispatch(valueChange(STATIC_KEYS.REPORT_PROTECTION_PLAN, protectionPlanConfig.protectionPlans));
      }
      const selectedIds = protectionPlanConfig.protectionPlans.split(',').map((id) => Number(id.trim())).filter((id) => !Number.isNaN(id));
      const selectedPlans = plans
        .filter((plan) => selectedIds.includes(Number(plan.id)))
        .map((plan) => ({ value: Number(plan.id), label: plan.name }));
      dispatch(valueChange('report.protectionPlan.protectionPlans-reportfilter-selected-option', selectedPlans));
    }
  };
}

export function cancelCreateSchedule(id, history) {
  return (dispatch) => {
    if (history) {
      history.push(REPORTS_PATH);
    }
    dispatch(closeModal());
    dispatch(setSelectedSchedule([]));
    dispatch(setActiveTabReport('2'));
    dispatch(clearValues());
    dispatch(valueChange('report.system.includeSystemOverView', true));
    dispatch(fetchDrPlans(STATIC_KEYS.UI_PROTECTION_PLANS));
    dispatch(valueChange(STATIC_KEYS.REPORT_DURATION_TYPE, 'month'));
  };
}

export function getHourlyStepFromCron(cronString) {
  if (!cronString) return 1;
  const parts = cronString.trim().split(' ');
  if (parts.length < 3) return 1;
  const hourField = parts[2]; // hour field (index 2)
  // Check for */N format
  if (hourField.startsWith('*/')) {
    const step = parseInt(hourField.replace('*/', ''), 10);
    return Number.isNaN(step) ? 1 : step;
  }
  return 1;
}
